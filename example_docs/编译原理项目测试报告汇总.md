这是一个将您上传的三个 PDF 文件（项目任务1、任务2、任务3的测试报告）内容合并整理后的完整 Markdown 文档。

------

# 编译原理项目测试报告汇总



**学生姓名**：李达良 **学号**：20203231004 **班级**：计科1班 **项目 Author**：李达良 

------

## 第一部分：项目任务一测试报告 (TINY 语言词法分析)

### 1. 准备工作

**TINY 语言的正则表达式设计：**





*(注：以上正则基于文档内容整理)* 

**测试用例 (sample.tny)：**





### 2. 测试过程与结果

#### 2.1 正则表达式输入

在系统界面输入上述正则表达式，并勾选“若词法分析忽略大小写”。

#### 2.2 NFA 生成

点击“开始分析”后生成 NFA。系统展示了从正则表达式到 NFA 的状态转换表。

- 

  **状态示例**：状态 1 接受输入转换到状态 0, 2, 4 等；状态 2 为终态。 

#### 2.3 DFA 生成

系统将 NFA 转换为 DFA。

- **状态集合示例**：

  - 状态 1: `{0, 2, 4, ..., 94}`

  - 状态 2 (终态): `{79, 80, 82, 83, 85, 95}` (对应 num)

  - 状态 3 (终态): {67, 68, 70, ..., 85, 95} (对应 letter)

    

#### 2.4 DFA 最小化

系统展示最小化后的 DFA 状态表，状态数量大幅减少，优化了自动机结构。

#### 2.5 词法分析程序生成

系统生成了 C 语言版本的词法分析器代码 (`lexer.c`)。

- 包含关键字数组：`else`, `end`, `if`, `read`, `repeat`, `then`, `until`, `write`。
- 包含保留字数组：`PLUS`, `MINUS`, `MULTIPLY`, `DIVIDE` 等。
- 编译运行结果：编译成功，输出大小约 168 KB，编译时间 0.428 秒。

#### 2.6 最终输出结果 (output.lex)

利用生成的程序对 `sample.tny` 进行分析，得到以下 Token 序列：





**结论**：对照 TINY 源程序，解析完全正确，任务一测试通过。

------

## 第二部分：项目任务二测试报告 (TINY 语言语法分析)

### 1. 准备工作

**TINY 语言 BNF 文法：**





语义函数定义：

定义了每个产生式对应的语法树节点生成规则（如 0 表示根节点，1 表示第一个子节点等）。

### 2. 测试过程与结果

#### 2.1 集合求解

- **First 集合**：

  - `addop`: `{MINUS, PLUS}`

  - `assign-stmt`: `{ID}`

  - `program`: `{ID, if, read, repeat, write}`

  - mulop: {DIVIDE, MOD, MULTIPLY}

    

- **Follow 集合**：

  - `program`: `{$}`

  - `statement`: `{$, SEMI, else, end, until}`

  - addop: {ID, LPAN, NUMBER}

    

#### 2.2 LR(0) DFA 生成

系统生成了 LR(0) 项目集族。

- **状态 0**: `program -> .stmt-sequence`

- 状态 1: program -> stmt-sequence. , stmt-sequence -> stmt-sequence . SEMI statement

  

#### 2.3 SLR(1) 分析表

系统检测到归约-移进冲突，通过 Follow 集解决，生成 SLR(1) 分析表。

- 状态 21 在输入 `SEMI` 时移进 (`s13`)。

- 状态 32 在输入 `else` 时归约 `r(statement->...)`。

- 状态 32 在输入 end 时归约 r(statement->...)。

  

#### 2.4 语法树生成与可视化

1. **代码生成**：系统利用 SLR(1) 表和语义函数生成了 C++ 代码 (`treeCode.cpp`)。

2. **编译运行**：编译生成的 C++ 代码，读取任务一生成的 `output.lex`。

3. **结果展示**：成功生成 `tree.out` 并可视化展示语法树。

   - **根节点**: `Root`

   - **子节点**: `stmt-sequence` -> `read: read`, `ID: xXx`

   - **子节点**: `if: if` -> `LT: <` ...

   - **子节点**: `repeat: repeat` ...

   - 子节点: ASSIGN: := ...

     



**结论**：任务二测试完全通过。

------

## 第三部分：项目任务三测试报告 (Mini-C 语言综合测试)

### 1. 任务一测试 (Mini-C 词法分析)

#### 1.1 准备工作

**Mini-C 正则表达式：**

- 关键字：`else if int float double return void do while`

- 符号：`+ - * / % < <= >= > = != ; , ( ) { } [ ]`

- 标识符：`(letter) (letter | num)*`

- 数字：num num* (. num num*)?

  

**测试用例 (sample.tny - Mini-C 版本)：**





#### 1.2 测试结果

1. **NFA/DFA 生成**：成功生成 Mini-C 的状态机。

2. 

   **词法程序生成**：生成 `lexer.c`，包含 `do`, `double`, `else` 等关键字定义。

3. 

   **编译运行**：编译成功 (0.387秒)，生成 `output.lex`。

4. **Token 输出 (部分)**：

   - `int: int`, `ID: x`, `SEMI: ;`

   - `double: double`, `ID: y`

   - `ID: arr`, `LMM: [`, `NUMBER: 100`, `RMM: ]`

   - void: void, ID: test

     



**结论**：Mini-C 词法分析测试通过。

### 2. 任务二测试 (Mini-C 语法分析)

#### 2.1 准备工作

Mini-C BNF 文法：

包含 program, definition-list, function-definition, compound-stmt, expression, if-stmt, while-stmt 等定义。

#### 2.2 测试结果

1. **First/Follow 集合**：

   - First(`additive-expression`): `{ID, LLM, NUMBER, ...}`

   - Follow(additive-expression): {DOU, EQ, LT, LTEQ, ...}

     

2. **SLR(1) 分析表**：

   - 检测到移进-归约冲突，系统自动处理（优先移进）。
   - 生成状态表，例如状态 10 在 `ID` 下移进 `s31`。

3. **语法树生成**：

   - 生成 `treeCode.cpp` (20KB)。
   - 解析 `output.lex` 并生成 `tree.out` (15KB)。

4. **可视化结果**：

   - `Root` -> `stmt-sequence`
   - 识别出 `read: read`, `ID: xXx`, `if: if`, `LT: <` 等结构 (注：此处截图似乎使用了与 TINY 类似的展示结构，但逻辑上对应 Mini-C 的解析流)。



**结论**：任务三（Mini-C 综合测试）完全通过。