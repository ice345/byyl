这是一个基于你上传的 PDF 文件《报告设计书-pdf版本.pdf》生成的完整 Markdown 文档。我已经去除了页眉、页脚和 OCR 识别产生的干扰字符，并对表格、代码块和标题进行了格式化，以便于阅读。

------

# 华南师范大学本科学生实验(实践)报告

院系：计算机学院

实验课程：编译原理项目

实验项目：编译原理项目

指导老师：黄煜廉

开课时间：2023~2024年度第2学期

专业：计算机科学与技术

班级：计科1班

学生：李达良

学号：20203231004





**实验时间**：2024年5月25日 1111



------

## 一、项目内容

### 第一个项目任务内容：

1. 以文本文件的方式输入某一高级程序设计语言的所有单词对应的正则表达式，系统需要提供一个操作界面，让用户打开某一语言的所有单词对应正则表达式文本文件，该文本文件的具体格式可根据自己实际的需要进行定义。2

   

   

2. 需要提供窗口以便用户可以查看转换得到的 NFA（可用状态转换表呈现）。3

   

   

3. 需要提供窗口以便用户可以查看转换得到的 DFA（可用状态转换表呈现）。4

   

   

4. 需要提供窗口以便用户可以查看转换得到的最小化 DFA（可用状态转换表呈现）。5

   

   

5. 需要提供窗口以便用户可以查看转换得到的词法分析程序（该分析程序需要用 C 语言描述）[只能使用讲稿中的方法一或方法二来生成词法分析程序]。6

   

   

6. 对要求(5)得到的源程序进行编译生成一个可执行程序，并以该高级程序设计语言的一个源程序进行测试，输出该源程序的单词编码。需要提供窗口以便用户可以查看该单词编码。7

   

   

7. **系统测试**：

   - (A) 先以 TINY 语言的所有单词的正则表达式作为文本来测试，生成一个 TINY 语言的词法分析源程序；

   - (B) 接着对这个词法分析源程序利用 C/C++ 编译器进行编译，并生成可执行程序；

   - (C) 以 `sample.tny` 来测试，输出该 TINY 语言源程序的单词编码文件 `sample.lex`。8

     

     

8. 要求应用程序为 Windows 界面。9

   

   

9. 书写完善的软件文档。10

   

   

### 第二个项目任务内容：

1. 以文本文件的方式输入某一高级程序设计语言的所有语法对应的 BNF 文法，因此系统需要提供一个操作界面，让用户打开某一语言的所有语法对应的 BNF 文法的文本文件，该文本文件的具体格式可根据自己实际的需要进行定义。11

   

   

2. 求出文法的每个非终结符号的 First 集合和 Follow 集合，并需要提供窗口以便用户可以查看该结果（可用两张表格的形式分别进行呈现）。12

   

   

3. 需要提供窗口以便用户可以查看文法对应的 LR(0) DFA 图。（可以用画图的方式呈现，也可用表格方式呈现该图点与边数据）。13

   

   

4. 构造出 SLR(1) 分析表，并需要提供窗口以便用户可以查看该结果（可用表格形式进行呈现）。14

   

   

5. 采用 SLR(1) 语法分析方法进行语法分析并生成相应的语法树，每个语句的语法树结构可根据实际的需要进行定义。（语法树需要采用树状形式进行呈现）。15

   

   

6. 以 TINY 语言的所有语法以及第一项任务的测试结果 `sample.lex` 作为测试，并生成对应的语法树并呈现出来。16

   

   

7. 要求应用程序为 Windows 界面。17

   

   

8. 书写完善的软件文档。18

   

   

9. 

   **选做内容**：可以生成某种中间代码【具体的中间代码形式可以自定】。19

   

   

### 第三个项目任务要求：

**Mini-C 语言作为测试**

1. 以 Mini-C 的词法进行测试，并以至少一个 Mini-C 源程序进行词法分析的测试（该 Mini-C 源程序需要自己根据 Mini-C 词法和语法编写出来，类似于 `sample.tny`）。20

   

   

2. 以 Mini-C 的语法进行测试，并以测试步骤(1)的源程序所生成的单词编码文件进行语法分析，生成对应的语法树。21

   

   

------

## 二、项目目的

第一个项目任务目的：

在这个项目中，我们将深入探讨程序编译过程中的重要步骤，并着手模仿实现一个编译器的关键功能。具体而言，项目的主要目标是开发一个词法分析程序生成器。这个生成器将能够解析特定格式的文件，这些文件包含了一个编程语言中各种词汇类型的正则表达式描述。通过分析这些表达式，生成器将自动构建一个词法分析器，该分析器能够识别并分类源代码中的词汇元素，如标识符、关键字、符号等。通过实际应用生成的词法分析器，我们可以有效地提高编译器的编译效率和准确性，为更深入的语法分析和语义处理奠定基础。22

第二个项目任务目的：

在这个项目中，我们将探索和实现一个高级编程语言的语法分析器，通过精确地处理 BNF 文法，实现语法的自动分析。本项目的主要目的是通过开发一个软件系统，该系统能够输入、解析和展示高级编程语言的 BNF 文法描述，并基于此自动生成 First 集和 Follow 集，构建 LR(0) DFA，生成 SLR(1) 分析表，执行 SLR(1) 语法分析，并最终构建语法树。该系统将提供一个用户友好的 Windows 操作界面，使用户能够方便地上传文法文件、查看各种分析结果，并通过图形化界面展示语法树和 LR(0) DFA 图、SLR(1) 分析表。此外，系统还将支持以 TINY 语言、MINI-C 语言的 BNF 文法和词法分析结果为基础进行测试，验证分析器的正确性和效能。通过这个项目，我们旨在深化对编译原理的理解，提高编译过程的自动化程度，并为可能的中间代码生成奠定基础。23

第三个项目任务目的：

测试前两个项目任务的完成出来的编译器的完成度和准确性。24

------

## 三、项目文档

### (一) 项目任务一

#### 1. 系统设计

##### 1.1 系统的关键数据结构



**(1) NFA 数据结构** 25



| **数据结构名称** | **类型** | **用途**     | **字段名称** | **字段类型**    | **说明**               |
| ---------------- | -------- | ------------ | ------------ | --------------- | ---------------------- |
| **nfaEdge**      | 结构体   | NFA 图的边   | c            | char            | 这个边的字符           |
|                  |          |              | next         | nfaNode*        | 这个边指向的下一个结点 |
| **nfaNode**      | 结构体   | NFA 图的结点 | id           | int             | 结点的唯一编号         |
|                  |          |              | isStart      | bool            | 初态标识               |
|                  |          |              | isEnd        | bool            | 终态标识               |
|                  |          |              | edges        | vector<nfaEdge> | 边集合                 |
| **NFA**          | 结构体   | NFA 图       | start        | nfaNode*        | 起始点                 |
|                  |          |              | end          | nfaNode*        | 终点                   |



**(2) DFA 数据结构** 26



| **数据结构名称** | **类型**        | **用途**             | **字段名称** | **字段类型**        | **说明**                         |
| ---------------- | --------------- | -------------------- | ------------ | ------------------- | -------------------------------- |
| **dfaNode**      | 结构体          | DFA 图的结点         | flag         | string              | 是否包含终态(+)或初态(-)         |
|                  |                 |                      | nfaStates    | set<int>            | 该 DFA 状态包含的 NFA 状态的集合 |
|                  |                 |                      | transitions  | map<char, set<int>> | 字符到下一状态的映射             |
| **dfaStatusSet** | set<set<int>>   | DFA 状态去重的结果集 |              |                     |                                  |
| **dfaTable**     | vector<dfaNode> | DFA 图最终的结果     |              |                     |                                  |



**(3) 最小化 DFA 数据结构** 27



| **数据结构名称** | **类型**           | **用途**                | **字段名称** | **字段类型**        | **说明**                 |
| ---------------- | ------------------ | ----------------------- | ------------ | ------------------- | ------------------------ |
| **dfaMinNode**   | 结构体             | 最小化 DFA 图结点       | flag         | string              | 是否包含终态(+)或初态(-) |
|                  |                    |                         | id           | int                 | 序号                     |
|                  |                    |                         | transitions  | map<char, set<int>> | 字符到下一状态的映射     |
| **dfaMinTable**  | vector<dfaMinNode> | 最小化 DFA 图最终的结果 |              |                     |                          |

##### 1.2 系统功能结构

在进行项目设计时，我将项目任务一分成了两个大模块：图形化操作模块和数据处理模块。28



- **图形化操作模块**：输入模块、展示模块、lex 文件展示模块。
- **数据处理模块**：正则表达式处理模块、NFA 处理模块、DFA 处理模块、DFA 最小化处理模块、词法分析程序生成模块。

#### 2. 功能模块设计及实现

##### 2.1 图形化操作模块



**(1) 描述**：通过 QT 实现 UI 的设计，给予一个正则表达式输入框。提供上传/下载正则表达式、忽略大小写选项和查看规则按钮。点击“开始分析”后，可查看 NFA、DFA、最小化 DFA 和词法分析程序结果。生成词法分析程序后，编译运行可获得 `output.lex`，并通过“查看 lex 文件”按钮读取。29



##### 2.2 正则表达式处理模块

**(1) 描述**：

1. 

   **输入格式**：30

   

   

   - 第一行：keyword（关键字），多个用 `|` 拼接。
   - 第二行：专用符号，用 `|` 连接，冲突符号用 `\` 包围（如 `\+\`）。
   - 第三行：第二行符号对应的名称。
   - 第四行：标识符正则（`\letter\` 表示字母，`\num\` 表示数字）。
   - 第五行：数字正则。
   - 第六行：注释正则（`~` 表示除结束符外任意字符）。

2. **符号替换**：使用 ASCII 不可打印字符替换冲突符号（如 `*`, `?`, `+`）。

3. **后处理**：处理 `[]`、`+`（正闭包）等扩展运算，转换为基本连接、选择、闭包运算。

(3) 核心算法：

使用 map 映射替换特殊符号，拼接生成最终的正则表达式字符串。31

##### 2.3 NFA 生成



**(1) 描述**：采用逆波兰表达式的双栈法（运算符栈、NFA 图栈），扫描正则表达式。遇到字符创建基本 NFA，遇到运算符（连接、选择、闭包）则弹出栈顶 NFA 进行合并。最后使用 DFS 生成状态转换表。32



**(3) 核心算法代码**：

C++

```
void createNFAStatusTable (NFA& nfa) {
    stack<nfaNode*> nfaStack;
    // ... DFS 遍历逻辑 ...
    // 记录状态转换信息 statusTable[currentNode->id].m[transitionChar].insert(nextNode->id);
    // 处理初态和终态标记
}
```

33



##### 2.4 DFA 生成



**(1) 描述**：采用子集构造法。从 NFA 起始状态的 $\epsilon$-闭包开始，计算字符闭包生成新状态，直到没有新状态产生。34



**(3) 核心算法代码**：

C++

```
void NFA2DFA (NFA& nfa) {
    // ... 初始化起始状态闭包 ...
    // ... 循环处理新状态 ...
    for (auto ch: dfaCharSet) {
        // 计算字符闭包
        // 判断是否为新状态，若是则加入队列
    }
}
```

35



##### 2.5 最小化 DFA 生成



**(1) 描述**：采用分割法。初始化将状态分为终态集和非终态集。遍历每个字符，尝试分割集合，直到不再有新的分割产生。36



**(3) 核心算法代码**：

C++

```
void DFAminimize() {
    // ... 初始化 divideVector (终态/非终态) ...
    while (continueFlag) {
        // 尝试分割 splitSet(i, ch);
    }
    // ... 构建 dfaMinTable ...
}
```

37



##### 2.6 词法生成程序代码生成

**(1) 描述**：基于最小化 DFA 构造 C 语言代码。

- 使用 Switch-Case 结构（讲稿方法二）实现状态跳转。

- 

  **编码标准**：关键字原样输出；标识符前加 `ID:`；数字前加 `NUMBER:`；操作符输出 `名称:op`；忽略注释；结尾加 `EOF:EOF`。38

  

  

(3) 核心算法代码：

拼接字符串生成 C 代码，处理字母、数字和特定符号的 Case 分支。

39

------

### (二) 项目任务二

#### 1. 系统设计

1.1 系统的关键数据结构 40



- **文法解析**：`grammarUnit` (gid, left, right), `grammarDeque`.
- **First/Follow**：`firstUnit` (set<string> S, bool isEpsilon), `followUnit`.
- **LR(0) DFA**：`dfaCell` (项目结构), `dfaState` (状态结构, 包含 cellV, nextStateVector).
- **SLR(1) 分析**：`SLRUnit` (map<string, string> m).
- **语法树**：`BTreeNode` (kind, value, nodeList).

##### 1.2 系统功能结构

分为图形化操作模块（输入、展示、语法树可视化）和数据处理模块（文法处理、First/Follow 求解、LR(0)/SLR(1) 分析、语法树代码生成）。41



#### 2. 功能模块设计及实现

##### 2.1 图形化操作模块

提供文法输入、First/Follow 结果展示、LR(0)/SLR(1) 分析结果展示及生成提示。代码生成模块用于生成语法树程序。42



##### 2.2 文法处理



**(1) 描述**：规定文法输入格式，第一行非终结符，第二行终结符。对文法进行增广处理（如果开始符号有多个产生式，增加 `zengguang` 符号）。43



(3) 核心算法：

解析输入字符串，构建 grammarMap 和 grammarDeque。自动识别并进行增广。

44

##### 2.3 First 集合求解



**(1) 描述**：迭代计算。对于 $X \rightarrow Y_1 Y_2...$, 将 First($Y_1$) 加入 First($X$)，若 $Y_1$ 含空串则继续处理 $Y_2$。循环直到集合不再变化。45



**(3) 核心算法代码**：

C++

```
bool calculateFirstSets() {
    // ... 遍历文法，更新 First 集合 ...
    // ... 检查集合大小是否变化 ...
}
```

46



##### 2.4 Follow 集合求解



**(1) 描述**：初始化 Follow(Start) = {$}。应用规则：若 $A \rightarrow \alpha B \beta$，把 First($\beta$)-{$\epsilon$} 加入 Follow($B$)；若 $\beta$ 为空或含 $\epsilon$，把 Follow($A$) 加入 Follow($B$)。循环直到稳定。47



**(3) 核心算法代码**：

C++

```
bool calculateFollowSets() {
    // ... 遍历文法 ...
    // Case A: A->...B, add Follow(A) to Follow(B)
    // Case B: A->...B beta, add First(beta) to Follow(B)
}
```

48



##### 2.5 LR(0) 表分析



**(1) 描述**：从增广文法开始，通过 DFS 生成状态。对每个状态求闭包（检查点号位置，非终结符展开），然后根据输入符号迁移生成新状态。49



**(3) 核心算法代码**：

C++

```
void generateLR0State(int stateId) {
    // DFS, 求闭包
    // ...
    // 生成新状态，校验重复
    // 递归 generateLR0State(nextStateId)
}
```

50



##### 2.6 SLR(1) 状态表生成



**(1) 描述**：检查冲突。对于移进-归约冲突，检查终结符是否在 Follow 集且状态中无完整项目；对于归约-归约冲突，检查 Follow 集交集是否为空。构建分析表时，利用 Follow 集解决归约动作。51



**(3) 核心算法代码**：

C++

```
int getSLR1Table() {
    // ... 遍历 LR(0) 状态 ...
    // 若是归约状态 (ds.isEnd)，根据 Follow 集填入 r(规约) 或 ACCEPT
    // 若是移进，填入 s(状态号)
}
```

52



##### 2.7 语法树生成

**(1) 描述**：

- 生成语法树代码：将 SLR(1) 表导出（序列化），在生成程序中解析。

- 使用分析栈（状态栈、符号栈、树节点栈）。

- 语义函数：规定每行文法对应的节点生成规则（-1:不生成，0:根，1+:子节点索引）。

- 生成 `tree.out` 文件，通过 QT 可视化展示。53

  

  

(3) 核心代码：

根据文法和用户定义的语义规则生成 C++ 代码字符串，用于构建语法树节点。

54

------

### (三) 项目任务三

#### 1. 项目任务一测试 (Mini-C 词法)

使用 Mini-C 的正则表达式（关键字、运算符、标识符、数字、注释）进行测试。

- **输入**：Mini-C 正则表达式。

- **输出**：NFA、DFA、最小化 DFA 及生成的词法分析器代码 (`_lexer.c`)。

- 

  **验证**：编译生成的 Lexer，输入 `sample.tny` (Mini-C 源码)，输出 `output.lex`。结果显示正确识别了 `int`, `ID`, `SEMI`, `LMM` 等 Token。55

  

  

#### 2. 项目任务二测试 (Mini-C 语法)

使用 Mini-C 的 BNF 文法进行测试。

- **输入**：Mini-C 文法。

- **输出**：First/Follow 集合、LR(0) 图、SLR(1) 分析表（处理了移进-归约冲突）。

- 

  **语法树生成**：结合任务一生成的 `output.lex` 和定义的语义函数，生成了 `tree.out` 并成功可视化展示了 Mini-C 程序的语法树结构。56

  

  

------

## 四、实验总结 (心得体会)

1. 

   **项目任务 1**：通过实现从 NFA 到 DFA 再到最小化 DFA 的转换，深入理解了自动机理论。特别是将理论应用于代码生成，实现了一个简单的词法分析器，验证了自动机在编程中的重要性。57

   

   

2. 

   **项目任务 2**：成功实现了文法处理、集合求解和 SLR(1) 分析表构建。图形化展示了 LR(0) DFA 和分析表，有助于理解分析过程。虽然未完成中间代码生成的选做内容，但实现了通过 SLR(1) 表驱动生成可视化语法树的功能，加深了对语法分析的理解。58

   

   

3. 

   **项目任务 3**：通过 Mini-C 语言的完整测试，将词法和语法分析结合。验证了系统的功能，证明了理论知识的应用能力。59

   

   

------

## 五、参考文献

《编译原理》课程课件 60



------

## 六、项目自评

总评自评：80分

理由：

1. **任务一**：完整实现正则到词法分析器的全过程，支持长正则和复杂状态，测试结果符合预期。界面交互良好。

2. **任务二**：完成了必做内容（First/Follow、LR(0)、SLR(1)、语法树生成）。支持多种文法，分析准确。未完成选做内容（中间代码）。

3. 

   **任务三**：通过了 Mini-C 的全流程测试，生成的单词编码准确，语法树展示完整。61

   

   